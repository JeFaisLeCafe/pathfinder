{"version":3,"sources":["PathfindingVisualizer/Node.jsx","PathfindingVisualizer/Title.jsx","algorithms/djikstra.js","algorithms/Astar.js","PathfindingVisualizer/Footer.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["NodeContainer","styled","div","props","isStart","isFinish","isShortedPath","isVisited","isWall","Node","Container","MyTitle","h1","Explanation","p","Title","djikstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","col","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","node","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","sort","nodeA","nodeB","Astar","endNode","x","y","f","g","h","debug","parent","start","end","openList","closedList","visitedNodes","lowInd","i","currentNode","curr","ret","shortestPath","reverse","_","n","getNeighbors","find","gScore","gScoreIsBest","Math","abs","search","Text","HoverText","Footer","onClick","window","open","Button","button","Row","BigContainer","Content","PathfindingVisualizer","state","mouseIsPressed","isDraggingStart","isDraggingFinish","GRID_COL_NUMBER","GRID_ROW_NUMBER","visualizeDjikstra","bind","animateShortestPath","reset","visualizeAstar","generateRandomWall","this","getInitialGrid","setState","currentRow","createNode","display","newGrid","j","resetedNode","resetNode","resetIsVisited","AstarNodes","animateAstar","console","log","setTimeout","JSON","parse","stringify","newNode","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animateDjikstra","getNewGridWithWallToggled","getNewGridWithStartMoved","cell","random","map","rowInd","key","colInd","onContextMenu","e","preventDefault","handleRightClick","onMouseDown","handleMouseDown","onMouseUp","handleMouseUp","onMouseEnter","handleMouseEnter","React","Component","App","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"qvBAGA,IAAMA,EAAgBC,IAAOC,IAAV,KAKG,SAAAC,GAAK,OACvBA,EAAMC,QACF,QACAD,EAAME,SACN,MACAF,EAAMG,cACN,UACAH,EAAMI,UACN,UACAJ,EAAMK,OACN,OACA,WAEY,SAAAL,GAAK,OACrBA,EAAMC,SAEFD,EAAME,SADN,GAGAF,EAAMG,cACN,wBACAH,EAAMI,UACN,oBACAJ,EAAMK,OACN,OAWO,SAASC,EAAKN,GAC3B,OAAO,kBAACH,EAAkBG,G,+YCxC5B,IAAMO,EAAYT,IAAOC,IAAV,KAOTS,EAAUV,IAAOW,GAAV,KAIPC,EAAcZ,IAAOa,EAAV,KAIF,SAASC,EAAMZ,GAC5B,OACE,kBAACO,EAAD,KACE,kBAACC,EAAD,0CACA,kBAACE,EAAD,0GAEoC,6BAFpC,qEAGqE,IACnE,6BAJF,mG,WCfC,SAASG,EAASC,EAAMC,EAAWC,GACxC,IAAKD,IAAcC,GAAcD,IAAcC,EAAY,OAAO,EAElE,IAAIC,EAAsB,GAC1BF,EAAUG,SAAW,EAGrB,IAFA,IAAMC,EAwBR,SAAqBL,GACnB,IADyB,EACrBM,EAAQ,GADa,cAETN,GAFS,IAEzB,2BAAsB,CAAC,IAAD,EAAbO,EAAa,sBACJA,GADI,IACpB,2BAAqB,CAAC,IAAbC,EAAY,QACnBF,EAAMG,KAAKD,IAFO,gCAFG,8BAOzB,OAAOF,EA/BgBI,CAAYV,GAE1BK,EAAeM,QAAQ,CAC9BC,EAAoBP,GACpB,IAAMQ,EAAcR,EAAeS,QAEnC,IAAID,EAAYtB,OAAhB,CAEA,GAAIsB,EAAYT,WAAaW,IAAU,OAAOZ,EAG9C,GAFAU,EAAYvB,WAAY,EACxBa,EAAoBM,KAAKI,GACrBA,IAAgBX,EAAY,OAAOC,EACvCa,EAAyBH,EAAab,KAI1C,SAASgB,EAAyBC,EAAMjB,GACtC,IAD4C,EACtCkB,EAiBR,SAA+BD,EAAMjB,GACnC,IAAIkB,EAAY,GACRV,EAAaS,EAAbT,IAAKD,EAAQU,EAARV,IACTA,EAAM,GAAGW,EAAUT,KAAKT,EAAKO,EAAM,GAAGC,IACtCD,EAAMP,EAAKW,OAAS,GAAGO,EAAUT,KAAKT,EAAKO,EAAM,GAAGC,IACpDA,EAAM,GAAGU,EAAUT,KAAKT,EAAKO,GAAKC,EAAM,IACxCA,EAAMR,EAAK,GAAGW,OAAS,GAAGO,EAAUT,KAAKT,EAAKO,GAAKC,EAAM,IAC7D,OAAOU,EAAUC,QAAO,SAACC,GAAD,OAAeA,EAAS9B,aAxB9B+B,CAAsBJ,EAAMjB,GADF,cAEvBkB,GAFuB,IAE5C,2BAAgC,CAAC,IAAxBE,EAAuB,QAC9BA,EAAShB,SAAWa,EAAKb,SAAW,EACpCgB,EAASE,aAAeL,GAJkB,+BA4B9C,SAASL,EAAoBP,GAC3BA,EAAekB,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMpB,SAAWqB,EAAMrB,Y,WCvDhD,SAASsB,EAAM1B,EAAMC,EAAW0B,GAE7C,IAAK,IAAIC,EAAI,EAAGA,EAAI5B,EAAKW,OAAQiB,IAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAI7B,EAAK4B,GAAGjB,OAAQkB,IAClC7B,EAAK4B,GAAGC,GAAGC,EAAI,EACf9B,EAAK4B,GAAGC,GAAGE,EAAI,EACf/B,EAAK4B,GAAGC,GAAGG,EAAI,EACfhC,EAAK4B,GAAGC,GAAGI,MAAQ,GACnBjC,EAAK4B,GAAGC,GAAGK,OAAS,KAIxB,OAGF,SAAgBlC,EAAMmC,EAAOC,GAC3B,IAAIC,EAAW,GACXC,EAAa,GACbC,EAAe,GACnBF,EAAS5B,KAAK0B,GAJkB,iBAS9B,IADA,IAAIK,EAAS,EACJC,EAAI,EAAGA,EAAIJ,EAAS1B,OAAQ8B,IAC/BJ,EAASI,GAAGX,EAAIO,EAASG,GAAQV,IACnCU,EAASC,GAGb,IAAIC,EAAcL,EAASG,GAG3B,GAAIE,EAAYnC,MAAQ6B,EAAI7B,KAAOmC,EAAYlC,MAAQ4B,EAAI5B,IAAK,CAG9D,IAFA,IAAImC,EAAOD,EACPE,EAAM,GACHD,EAAKT,QACVU,EAAInC,KAAKkC,GACTA,EAAOA,EAAKT,OAEd,MAAM,CAAN,EAAO,CAACW,aAAcD,EAAIE,UAAWP,iBAIvCQ,SAASV,GAAU,SAAAW,GACjB,OAAOA,EAAExC,MAAQkC,EAAYlC,KAAOwC,EAAEzC,MAAQmC,EAAYnC,OAE5D+B,EAAW7B,KAAKiC,GAGhB,IAFA,IAAIxB,EAsDR,SAAsBlB,EAAMiB,GAC1B,IAAI2B,EAAM,GACNhB,EAAIX,EAAKV,IACTsB,EAAIZ,EAAKT,IAETR,EAAK4B,EAAI,IAAM5B,EAAK4B,EAAI,GAAGC,IAC7Be,EAAInC,KAAKT,EAAK4B,EAAI,GAAGC,IAEnB7B,EAAK4B,EAAI,IAAM5B,EAAK4B,EAAI,GAAGC,IAC7Be,EAAInC,KAAKT,EAAK4B,EAAI,GAAGC,IAEnB7B,EAAK4B,GAAGC,EAAI,IAAM7B,EAAK4B,GAAGC,EAAI,IAChCe,EAAInC,KAAKT,EAAK4B,GAAGC,EAAI,IAEnB7B,EAAK4B,GAAGC,EAAI,IAAM7B,EAAK4B,GAAGC,EAAI,IAChCe,EAAInC,KAAKT,EAAK4B,GAAGC,EAAI,IAEvB,OAAOe,EAvEWK,CAAajD,EAAM0C,GAhCL,WAkCrBD,GACP,IAAIrB,EAAWF,EAAUuB,GACzB,GACEH,EAAWY,MACT,SAAAF,GAAC,OAAI5B,EAASZ,MAAQwC,EAAExC,KAAOY,EAASb,MAAQyC,EAAEzC,QAEpDa,EAAS7B,OAGT,iBAKF,IAgCaU,EAAWC,EAhCpBiD,EAAST,EAAYX,EAAI,EACzBqB,GAAe,EAGhBf,EAASa,MAAK,SAAAF,GAAC,OAAI5B,EAASZ,MAAQwC,EAAExC,KAAOY,EAASb,MAAQyC,EAAEzC,OASxD4C,EAAS/B,EAASW,IAE3BqB,GAAe,IANfA,GAAe,EACfhC,EAASY,GAsBE/B,EAtBYmB,EAsBDlB,EAtBWkC,EAwBrCiB,KAAKC,IAAIrD,EAAUO,IAAMN,EAAWM,KACpC6C,KAAKC,IAAIrD,EAAUM,IAAML,EAAWK,MAxBhC8B,EAAS5B,KAAKW,GACdmB,EAAa9B,KAAKW,IAMhBgC,IAGFhC,EAASc,OAASQ,EAClBtB,EAASW,EAAIoB,EACb/B,EAASU,EAAIV,EAASW,EAAIX,EAASY,IArC9BS,EAAI,EAAGA,EAAIvB,EAAUP,OAAQ8B,IAAK,EAAlCA,IA5BX,KAAOJ,EAAS1B,OAAS,GAAG,CAAC,IAAD,wCAuE5B,MAAO,CAACkC,aAAc,GAAIN,gBAhFnBgB,CAAOvD,EAAMC,EAAW0B,G,2fCXjC,IAAMlC,EAAYT,IAAOC,IAAV,KAUTuE,EAAOxE,IAAOa,EAAV,KAIJ4D,EAAYzE,YAAOwE,EAAPxE,CAAH,KAQA,SAAS0E,EAAOxE,GAC7B,OACE,kBAAC,EAAD,KACE,kBAACsE,EAAD,wCACA,kBAACC,EAAD,CACEE,QAAS,kBACPC,OAAOC,KAAK,6CAA8C,YAF9D,UAOA,kBAACJ,EAAD,CACEE,QAAS,kBACPC,OAAOC,KACL,8DACA,YAJN,a,s8BC3BN,IAAMC,EAAS9E,IAAO+E,OAAV,KAgBNC,EAAMhF,IAAOC,IAAV,KAIHgF,EAAejF,IAAOC,IAAV,KAIZQ,EAAYT,IAAOC,IAAV,KAQTiF,EAAUlF,IAAOC,IAAV,KAUQkF,E,kDACnB,WAAYjF,GAAQ,IAAD,8BACjB,gBACKkF,MAAQ,CACXpE,KAAM,GACNqE,gBAAgB,EAChBC,iBAAiB,EACjBC,kBAAkB,EAClBtE,UAAW,CAAEO,IAbI,EAaiBD,IAZjB,GAajBL,WAAY,CAAEM,IAZIgE,GAYkBjE,IAXlBkE,KAapB,EAAKC,kBAAoB,EAAKA,kBAAkBC,KAAvB,gBACzB,EAAKC,oBAAsB,EAAKA,oBAAoBD,KAAzB,gBAC3B,EAAKE,MAAQ,EAAKA,MAAMF,KAAX,gBAEb,EAAKG,eAAiB,EAAKA,eAAeH,KAApB,gBACtB,EAAKI,mBAAqB,EAAKA,mBAAmBJ,KAAxB,gBAfT,E,gEAmBjB,IAAM3E,EAAOgF,KAAKC,iBAClBD,KAAKE,SAAS,CAAElF,W,uCAKhB,IADA,IAAIA,EAAO,GACFO,EAAM,EAAGA,EAhCE,GAgCqBA,IAAO,CAE9C,IADA,IAAI4E,EAAa,GACR3E,EAAM,EAAGA,EAnCA,GAmCuBA,IACvC2E,EAAW1E,KAAKuE,KAAKI,WAAW5E,EAAKD,IAEvCP,EAAKS,KAAK0E,GAEZ,OAAOnF,I,iCAGEQ,EAAKD,GACd,MAAO,CACLC,MACAD,MACApB,QACEoB,IAAQyE,KAAKZ,MAAMnE,UAAUM,KAAOC,IAAQwE,KAAKZ,MAAMnE,UAAUO,IACnEpB,SACEmB,IAAQyE,KAAKZ,MAAMlE,WAAWK,KAAOC,IAAQwE,KAAKZ,MAAMlE,WAAWM,IACrEJ,SAAUW,IACVzB,WAAW,EACXC,QAAQ,EACR+B,aAAc,Q,gCAIRL,GACR,OAAO,2BACFA,GADL,IAEE3B,WAAW,EACXD,eAAe,EACfgG,QAAStE,IACTO,aAAc,S,uCAMhB,IADA,IAAIgE,EAAUvC,YAAYiC,KAAKZ,MAAMpE,MAC5ByC,EAAI,EAAGA,EAAI6C,EAAQ3E,OAAQ8B,IAClC,IAAK,IAAI8C,EAAI,EAAGA,EAAID,EAAQ7C,GAAG9B,OAAQ4E,IAAK,CAC1C,IAAMC,EAAcR,KAAKS,UAAUH,EAAQ7C,GAAG8C,IAC9CD,EAAQ7C,GAAG8C,GAAKC,EAIpB,OADAR,KAAKE,SAAS,CAAElF,KAAMsF,IACfA,I,uCAIP,IAAItF,EAAO+C,YAAYiC,KAAKU,kBAQtBC,EAAajE,EAAM1B,EAPPA,EAAKgF,KAAKZ,MAAMnE,UAAUM,KAAKyE,KAAKZ,MAAMnE,UAAUO,KAEpER,EAAKgF,KAAKZ,MAAMlE,WAAWK,KAAKyE,KAAKZ,MAAMlE,WAAWM,MAMxDwE,KAAKY,aAAaD,K,mCAGPA,GAAa,IAAD,OACvBE,QAAQC,IAAI,QAASH,GACrB,IAFuB,eAEdlD,GACP,GAAIA,IAAMkD,EAAWpD,aAAa5B,OAIhC,OAHAoF,YAAW,WACT,EAAKnB,oBAAoBe,EAAW9C,gBA5F3B,GA6FKJ,GACV,CAAN,UAEFsD,YAAW,WACT,IAAM9E,EAAO0E,EAAWpD,aAAaE,GAC/B6C,EAAUU,KAAKC,MAAMD,KAAKE,UAAU,EAAK9B,MAAMpE,OAC/CmG,EAAO,2BAAQlF,GAAR,IAAc3B,WAAW,IACtCgG,EAAQrE,EAAKV,KAAKU,EAAKT,KAAO2F,EAC9B,EAAKjB,SAAS,CAAElF,KAAMsF,MArGX,GAsGG7C,IAbTA,EAAI,EAAGA,GAAKkD,EAAWpD,aAAa5B,OAAQ8B,IAAK,CAAC,IAAD,IAAjDA,GAAiD,qC,0CAkB1D,IAAIzC,EAAO+C,YAAYiC,KAAKU,kBACtBzF,EAAYD,EAAKgF,KAAKZ,MAAMnE,UAAUM,KAAKyE,KAAKZ,MAAMnE,UAAUO,KAChEN,EACJF,EAAKgF,KAAKZ,MAAMlE,WAAWK,KAAKyE,KAAKZ,MAAMlE,WAAWM,KAClDL,EAAsBJ,EAASC,EAAMC,EAAWC,GAChDkG,EHtGH,SAAqClG,GAG1C,IAFA,IAAIkG,EAA2B,GAC3B1D,EAAcxC,EACK,OAAhBwC,GACL0D,EAAyBC,QAAQ3D,GACjCA,EAAcA,EAAYpB,aAE5B,OAAO8E,EG+F4BE,CAA4BpG,GAE7D8E,KAAKuB,gBAAgBpG,EAAqBiG,K,0CAGxBA,GAClB,IAD6C,IAAD,kBACnC3D,GACPsD,YAAW,WACT,IAAM9E,EAAOmF,EAAyB3D,GAChC6C,EAAUU,KAAKC,MAAMD,KAAKE,UAAU,EAAK9B,MAAMpE,OAC/CmG,EAAO,2BAAQlF,GAAR,IAAc5B,eAAe,IAC1CiG,EAAQrE,EAAKV,KAAKU,EAAKT,KAAO2F,EAC9B,EAAKjB,SAAS,CAAElF,KAAMsF,MA5HX,GA6HG7C,IAPTA,EAAI,EAAGA,EAAI2D,EAAyBzF,OAAQ8B,IAAM,EAAlDA,K,sCAWKtC,EAAqBiG,GACnC,IAD8D,IAAD,kBACpD3D,GACP,GAAIA,IAAMtC,EAAoBQ,OAI5B,OAHAoF,YAAW,WACT,EAAKnB,oBAAoBwB,KArIhB,GAsIK3D,GACV,CAAN,UAEFsD,YAAW,WACT,IAAM9E,EAAOd,EAAoBsC,GAC3B6C,EAAUU,KAAKC,MAAMD,KAAKE,UAAU,EAAK9B,MAAMpE,OAC/CmG,EAAO,2BAAQlF,GAAR,IAAc3B,WAAW,IACtCgG,EAAQrE,EAAKV,KAAKU,EAAKT,KAAO2F,EAC9B,EAAKjB,SAAS,CAAElF,KAAMsF,MA9IX,GA+IG7C,IAbTA,EAAI,EAAGA,GAAKtC,EAAoBQ,OAAQ8B,IAAK,CAAC,IAAD,IAA7CA,GAA6C,qC,gDAiB9BzC,EAAMO,EAAKC,GACnC,IAAI8E,EAAUvC,YAAY/C,GACtBiB,EAAOqE,EAAQ/E,GAAKC,GACxB,IAAKS,EAAK9B,UAAY8B,EAAK7B,SAAU,CACnC,IAAM+G,EAAO,2BAAQlF,GAAR,IAAc1B,QAAS0B,EAAK1B,SACzC+F,EAAQ/E,GAAKC,GAAO2F,EAEtB,OAAOb,I,+CAEgBtF,EAAMO,EAAKC,GAClC,IAAI8E,EAAUvC,YAAY/C,GACtBiB,EAAOqE,EAAQ/E,GAAKC,GACxB,IAAKS,EAAK7B,SAAU,CAClB,IAAM+G,EAAO,2BAAQlF,GAAR,IAAc9B,SAAS,IACpCmG,EAAQ/E,GAAKC,GAAO2F,EAEtB,OAAOb,I,uCAGQ/E,EAAKC,GACpB,IAAI8E,EAAUvC,YAAYiC,KAAKZ,MAAMpE,MACjCiB,EAAOqE,EAAQ/E,GAAKC,GA2BxB,OAxBIwE,KAAKZ,MAAME,kBAAoBrD,EAAK7B,UACtC6B,EAAI,2BAAQA,GAAR,IAAc9B,SAAS,EAAMI,QAAQ,IACzCyF,KAAKE,SAAS,CAAEZ,iBAAiB,EAAOrE,UAAW,CAAEM,MAAKC,UACjDwE,KAAKZ,MAAMG,mBAAqBtD,EAAK9B,SAC9C8B,EAAI,2BAAQA,GAAR,IAAc7B,UAAU,EAAMG,QAAQ,IAC1CyF,KAAKE,SAAS,CAAEX,kBAAkB,EAAOrE,WAAY,CAAEM,MAAKD,UAG3DyE,KAAKZ,MAAME,iBACXU,KAAKZ,MAAMG,mBACZtD,EAAK9B,QAKJ6F,KAAKZ,MAAME,iBACXU,KAAKZ,MAAMG,mBACZtD,EAAK7B,WAEL6B,EAAI,2BAAQA,GAAR,IAAc7B,UAAU,EAAOG,QAAQ,IAC3CyF,KAAKE,SAAS,CAAEX,kBAAkB,MARlCtD,EAAI,2BAAQA,GAAR,IAAc9B,SAAS,EAAOI,QAAQ,IAC1CyF,KAAKE,SAAS,CAAEZ,iBAAiB,KASnCgB,EAAQ/E,GAAKC,GAAOS,EACpB+D,KAAKE,SAAS,CAAElF,KAAMsF,KACf,I,sCAGO/E,EAAKC,GACnB,IAAMS,EAAO+D,KAAKZ,MAAMpE,KAAKO,GAAKC,GAClC,GAAIS,EAAK9B,QAEP6F,KAAKE,SAAS,CAAEZ,iBAAiB,SAC5B,GAAIrD,EAAK7B,SACd4F,KAAKE,SAAS,CAAEX,kBAAkB,QAC7B,CACL,IAAMe,EAAUN,KAAKwB,0BAA0BxB,KAAKZ,MAAMpE,KAAMO,EAAKC,GACrEwE,KAAKE,SAAS,CAAElF,KAAMsF,IACtBN,KAAKE,SAAS,CAAEb,gBAAgB,O,uCAInB9D,EAAKC,GACpB,GAAKwE,KAAKZ,MAAMC,eAAhB,CAEA,IAAIiB,EAAUN,KAAKZ,MAAMpE,KACnBiB,EAAOqE,EAAQ/E,GAAKC,GACtBwE,KAAKZ,MAAME,gBAEbgB,EAAUN,KAAKyB,yBAAyBnB,EAAS/E,EAAKC,GAC7CS,EAAK7B,SACd4F,KAAKE,SAAS,CAAEX,kBAAkB,IAElCe,EAAUN,KAAKwB,0BAA0BlB,EAAS/E,EAAKC,GAEzDwE,KAAKE,SAAS,CAAElF,KAAMsF,O,sCAItBN,KAAKE,SAAS,CACZb,gBAAgB,M,2CAKlBW,KAAKH,QAGL,IADA,IAAM7E,EAAO+C,YAAYiC,KAAKZ,MAAMpE,MAC3ByC,EAAI,EAAGA,EAAIzC,EAAKW,OAAQ8B,IAC/B,IAAK,IAAI8C,EAAI,EAAGA,EAAIvF,EAAKyC,GAAG9B,OAAQ4E,IAAK,CACvC,IAAMmB,EAAO1G,EAAKyC,GAAG8C,GACjBlC,KAAKsD,SAAW,KAAQD,EAAKvH,UAAYuH,EAAKtH,WAChDY,EAAKyC,GAAG8C,GAAR,2BAAkBvF,EAAKyC,GAAG8C,IAA1B,IAA8BhG,QAAQ,KAI5CyF,KAAKE,SAAS,CAAElF,W,8BAIhB,IAAMA,EAAOgF,KAAKC,iBAClBD,KAAKE,SAAS,CAAElF,W,+BAGR,IAAD,OACP,OACE,kBAACiE,EAAD,KACE,kBAAC,EAAD,KACE,kBAACnE,EAAD,MACA,kBAACoE,EAAD,KACE,kBAACJ,EAAD,CAAQH,QAASqB,KAAKN,mBAAtB,kCAGA,kBAACZ,EAAD,CAAQH,QAASqB,KAAKF,gBAAtB,0BAGA,kBAAChB,EAAD,CAAQH,QAASqB,KAAKD,oBAAtB,wBAGA,kBAACjB,EAAD,CAAQH,QAASqB,KAAKH,OAAtB,SACCG,KAAKZ,MAAMpE,KAAK4G,KAAI,SAACrG,EAAKsG,GACzB,OACE,kBAAC7C,EAAD,CAAK8C,IAAKD,GACPtG,EAAIqG,KAAI,SAAC3F,EAAM8F,GACd,OACE,kBAACvH,EAAD,eACEsH,IAAKC,GACD9F,EAFN,CAGE+F,cAAe,SAACC,GACdA,EAAEC,iBACF,EAAKC,iBAAiBN,EAAQE,IAEhCK,YAAa,SAACH,GAEK,IAAbA,EAAElD,QACJ,EAAKsD,gBAAgBR,EAAQE,IAGjCO,UAAW,kBAAM,EAAKC,iBACtBC,aAAc,kBACZ,EAAKC,iBAAiBZ,EAAQE,gBAUhD,kBAACrD,EAAD,W,GA3S2CgE,IAAMC,WCvC1CC,MARf,WACE,OACE,yBAAKC,UAAU,OACb,kBAAC,EAAD,QCKcC,QACW,cAA7BlE,OAAOmE,SAASC,UAEe,UAA7BpE,OAAOmE,SAASC,UAEhBpE,OAAOmE,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLjD,QAAQiD,MAAMA,EAAMC,c","file":"static/js/main.4f9ea814.chunk.js","sourcesContent":["import React from \"react\";\nimport styled from \"styled-components\";\n\nconst NodeContainer = styled.div`\n  width: 40px;\n  height: 40px;\n  border: solid 1px black;\n  margin: 1px;\n  background-color: ${props =>\n    props.isStart\n      ? \"green\"\n      : props.isFinish\n      ? \"red\"\n      : props.isShortedPath\n      ? \"#D2A1B8\"\n      : props.isVisited\n      ? \"#011638\"\n      : props.isWall\n      ? \"grey\"\n      : \"white\"};\n  transition: 1s easy-in-out;\n  animation-name: ${props =>\n    props.isStart\n      ? \"\"\n      : props.isFinish\n      ? \"\"\n      : props.isShortedPath\n      ? \"shortestPathAnimation\"\n      : props.isVisited\n      ? \"visitedAnimation\"\n      : props.isWall\n      ? \"\"\n      : \"\"};\n  animation-duration: 0.8s;\n  animation-timing-function: ease-out;\n  animation-delay: 0;\n  animation-direction: alternate;\n  animation-iteration-count: 1;\n  animation-fill-mode: fowards;\n  animation-play-state: running;\n`;\n\nexport default function Node(props) {\n  return <NodeContainer {...props}></NodeContainer>;\n}\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst Container = styled.div`\n  text-align: center;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  flex-direction: column;\n`;\nconst MyTitle = styled.h1`\n  font-size: 34px;\n  line-height: 35px;\n`;\nconst Explanation = styled.p`\n  font-size: 22px;\n`;\n\nexport default function Title(props) {\n  return (\n    <Container>\n      <MyTitle>Pathfinding Algorithms Visualizer</MyTitle>\n      <Explanation>\n        Hi, and welcome here ! You can play with this tool to visualize\n        different pathfinding algorithms. <br />\n        With a right click on start or finish point, you can deplace them.{\" \"}\n        <br />\n        With a left click, you can create walls ! Then just choose an algorithm\n        and see what happens !\n      </Explanation>\n    </Container>\n  );\n}\n","// const node = {\n//   row,\n//   col,\n//   isVisited,\n//   distance,\n// };\n\nexport function djikstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) return false;\n\n  let visitedNodesInOrder = [];\n  startNode.distance = 0; // initialization\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // if we encounter a wall, we skip it\n    if (closestNode.isWall) continue;\n    // if closestNode is to infinity, then we are trapped\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const neighbors = getUnvisitedNeighbors(node, grid);\n  for (let neighbor of neighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getAllNodes(grid) {\n  let nodes = [];\n  for (let row of grid) {\n    for (let col of row) {\n      nodes.push(col);\n    }\n  }\n  return nodes;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  let neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import * as _ from \"lodash\";\n\nexport default function Astar(grid, startNode, endNode) {\n  // initialization\n  for (let x = 0; x < grid.length; x++) {\n    for (let y = 0; y < grid[x].length; y++) {\n      grid[x][y].f = 0;\n      grid[x][y].g = 0;\n      grid[x][y].h = 0;\n      grid[x][y].debug = \"\";\n      grid[x][y].parent = null;\n    }\n  }\n\n  return search(grid, startNode, endNode);\n}\n\nfunction search(grid, start, end) {\n  let openList = [];\n  let closedList = [];\n  let visitedNodes = [];\n  openList.push(start);\n\n  while (openList.length > 0) {\n    // Grab the lowest f(x) to process next\n    let lowInd = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].f < openList[lowInd].f) {\n        lowInd = i;\n      }\n    }\n    let currentNode = openList[lowInd];\n\n    // End case -- result has been found, return the traced path\n    if (currentNode.row === end.row && currentNode.col === end.col) {\n      let curr = currentNode;\n      let ret = [];\n      while (curr.parent) {\n        ret.push(curr);\n        curr = curr.parent;\n      }\n      return {shortestPath: ret.reverse(), visitedNodes};\n    }\n\n    // Normal case -- move currentNode from open to closed, process each of its neighbors\n    _.remove(openList, n => {\n      return n.col === currentNode.col && n.row === currentNode.row;\n    });\n    closedList.push(currentNode);\n    let neighbors = getNeighbors(grid, currentNode);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      if (\n        closedList.find(\n          n => neighbor.col === n.col && neighbor.row === n.row\n        ) ||\n        neighbor.isWall\n      ) {\n        // not a valid node to process, skip to next neighbor\n        continue;\n      }\n\n      // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbor is the shortest one we have seen yet\n      let gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor\n      let gScoreIsBest = false;\n\n      if (\n        !openList.find(n => neighbor.col === n.col && neighbor.row === n.row)\n      ) {\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n\n        gScoreIsBest = true;\n        neighbor.h = heuristic(neighbor, end);\n        openList.push(neighbor);\n        visitedNodes.push(neighbor);\n      } else if (gScore < neighbor.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true;\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbor.parent = currentNode;\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n      }\n    }\n  }\n\n  // No result was found -- empty array signifies failure to find path\n  return {shortestPath: [], visitedNodes};\n}\n\nfunction heuristic(startNode, finishNode) {\n  return (\n    Math.abs(startNode.col - finishNode.col) +\n    Math.abs(startNode.row - finishNode.row)\n  );\n}\nfunction getNeighbors(grid, node) {\n  let ret = [];\n  let x = node.row;\n  let y = node.col;\n\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n  if (grid[x][y - 1] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n  if (grid[x][y + 1] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n  return ret;\n}\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: row;\n  height: 50px;\n  justify-content: space-around;\n  align-items: center;\n  width: 100%;\n  background-color: #1e2019;\n`;\n\nconst Text = styled.p`\n  font-size: 24px;\n  color: white;\n`;\nconst HoverText = styled(Text)`\n  :hover {\n    color: #1e2019;\n    background-color: lightgrey;\n    cursor: pointer;\n  }\n`;\n\nexport default function Footer(props) {\n  return (\n    <Container>\n      <Text>Made by Pierre-Étienne Soury</Text>\n      <HoverText\n        onClick={() =>\n          window.open(\"https://github.com/JeFaisLeCafe/pathfinder\", \"_blank\")\n        }\n      >\n        Github\n      </HoverText>\n      <HoverText\n        onClick={() =>\n          window.open(\n            \"https://www.linkedin.com/in/pierre-etienne-soury-66050511b/\",\n            \"_blank\"\n          )\n        }\n      >\n        LinkedIn\n      </HoverText>\n    </Container>\n  );\n}\n","import React from \"react\";\nimport Node from \"./Node\";\nimport Title from \"./Title\";\nimport styled from \"styled-components\";\nimport { djikstra, getNodesInShortestPathOrder } from \"../algorithms/djikstra\";\nimport Astar from \"../algorithms/Astar\";\nimport * as _ from \"lodash\";\nimport Footer from \"./Footer\";\n\nconst Button = styled.button`\n  padding: 7px 15px;\n  font-size: 25px;\n  margin: 10px;\n  background-color: #011638;\n  color: white;\n  border: none;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n    sans-serif;\n\n  :hover {\n    cursor: pointer;\n    background-color: #d2a1b8;\n  }\n`;\nconst Row = styled.div`\n  display: flex;\n  flex-direction: row;\n`;\nconst BigContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n`;\nconst Container = styled.div`\n  min-height: 100vh;\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n`;\nconst Content = styled.div`\n  max-width: 95vw;\n`;\nconst GRID_COL_NUMBER = 30;\nconst GRID_ROW_NUMBER = 15;\nconst START_NODE_COL = 5;\nconst START_NODE_ROW = 5;\nconst FINISH_NODE_COL = GRID_COL_NUMBER - 5;\nconst FINISH_NODE_ROW = GRID_ROW_NUMBER - 5;\nconst TIME_PARAM = 50;\nexport default class PathfindingVisualizer extends React.Component {\n  constructor(props) {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      isDraggingStart: false,\n      isDraggingFinish: false,\n      startNode: { col: START_NODE_COL, row: START_NODE_ROW },\n      finishNode: { col: FINISH_NODE_COL, row: FINISH_NODE_ROW },\n    };\n    this.visualizeDjikstra = this.visualizeDjikstra.bind(this);\n    this.animateShortestPath = this.animateShortestPath.bind(this);\n    this.reset = this.reset.bind(this);\n\n    this.visualizeAstar = this.visualizeAstar.bind(this);\n    this.generateRandomWall = this.generateRandomWall.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n\n  getInitialGrid() {\n    let grid = [];\n    for (let row = 0; row < GRID_ROW_NUMBER; row++) {\n      let currentRow = [];\n      for (let col = 0; col < GRID_COL_NUMBER; col++) {\n        currentRow.push(this.createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }\n\n  createNode(col, row) {\n    return {\n      col,\n      row,\n      isStart:\n        row === this.state.startNode.row && col === this.state.startNode.col,\n      isFinish:\n        row === this.state.finishNode.row && col === this.state.finishNode.col,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n    };\n  }\n\n  resetNode(node) {\n    return {\n      ...node,\n      isVisited: false,\n      isShortedPath: false,\n      display: Infinity,\n      previousNode: null,\n    };\n  }\n\n  resetIsVisited() {\n    let newGrid = _.cloneDeep(this.state.grid);\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[i].length; j++) {\n        const resetedNode = this.resetNode(newGrid[i][j]);\n        newGrid[i][j] = resetedNode;\n      }\n    }\n    this.setState({ grid: newGrid });\n    return newGrid;\n  }\n\n  visualizeAstar() {\n    let grid = _.cloneDeep(this.resetIsVisited());\n    const startNode = grid[this.state.startNode.row][this.state.startNode.col];\n    const finishNode =\n      grid[this.state.finishNode.row][this.state.finishNode.col];\n    //const visitedNodesInOrder = djikstra(grid, startNode, finishNode);\n    //const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    //this.animateAstar(visitedNodesInOrder, nodesInShortestPathOrder);\n    const AstarNodes = Astar(grid, startNode, finishNode); // {visitedNodes: [], shortestPath: []}\n    this.animateAstar(AstarNodes);\n  }\n\n  animateAstar(AstarNodes) {\n    console.log(\"Astar\", AstarNodes);\n    for (let i = 0; i <= AstarNodes.visitedNodes.length; i++) {\n      if (i === AstarNodes.visitedNodes.length) {\n        setTimeout(() => {\n          this.animateShortestPath(AstarNodes.shortestPath);\n        }, TIME_PARAM * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = AstarNodes.visitedNodes[i];\n        const newGrid = JSON.parse(JSON.stringify(this.state.grid));\n        const newNode = { ...node, isVisited: true };\n        newGrid[node.row][node.col] = newNode;\n        this.setState({ grid: newGrid });\n      }, TIME_PARAM * i);\n    }\n  }\n\n  visualizeDjikstra() {\n    let grid = _.cloneDeep(this.resetIsVisited());\n    const startNode = grid[this.state.startNode.row][this.state.startNode.col];\n    const finishNode =\n      grid[this.state.finishNode.row][this.state.finishNode.col];\n    const visitedNodesInOrder = djikstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    this.animateDjikstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const newGrid = JSON.parse(JSON.stringify(this.state.grid));\n        const newNode = { ...node, isShortedPath: true };\n        newGrid[node.row][node.col] = newNode;\n        this.setState({ grid: newGrid });\n      }, TIME_PARAM * i);\n    }\n  }\n\n  animateDjikstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, TIME_PARAM * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const newGrid = JSON.parse(JSON.stringify(this.state.grid));\n        const newNode = { ...node, isVisited: true };\n        newGrid[node.row][node.col] = newNode;\n        this.setState({ grid: newGrid });\n      }, TIME_PARAM * i);\n    }\n  }\n\n  getNewGridWithWallToggled(grid, row, col) {\n    let newGrid = _.cloneDeep(grid);\n    let node = newGrid[row][col];\n    if (!node.isStart && !node.isFinish) {\n      const newNode = { ...node, isWall: !node.isWall };\n      newGrid[row][col] = newNode;\n    }\n    return newGrid;\n  }\n  getNewGridWithStartMoved(grid, row, col) {\n    let newGrid = _.cloneDeep(grid);\n    let node = newGrid[row][col];\n    if (!node.isFinish) {\n      const newNode = { ...node, isStart: true };\n      newGrid[row][col] = newNode;\n    }\n    return newGrid;\n  }\n\n  handleRightClick(row, col) {\n    let newGrid = _.cloneDeep(this.state.grid);\n    let node = newGrid[row][col];\n    // we handle here all the different possibilities after a left click\n    // first, cases where we are moving the start/finish, and setting a new start/finish\n    if (this.state.isDraggingStart && !node.isFinish) {\n      node = { ...node, isStart: true, isWall: false };\n      this.setState({ isDraggingStart: false, startNode: { row, col } });\n    } else if (this.state.isDraggingFinish && !node.isStart) {\n      node = { ...node, isFinish: true, isWall: false };\n      this.setState({ isDraggingFinish: false, finishNode: { col, row } });\n    } //then cases where we are starting to move, ie right clicking on start/finish\n    else if (\n      !this.state.isDraggingStart &&\n      !this.state.isDraggingFinish &&\n      node.isStart\n    ) {\n      node = { ...node, isStart: false, isWall: false };\n      this.setState({ isDraggingStart: true });\n    } else if (\n      !this.state.isDraggingStart &&\n      !this.state.isDraggingFinish &&\n      node.isFinish\n    ) {\n      node = { ...node, isFinish: false, isWall: false };\n      this.setState({ isDraggingFinish: true });\n    }\n    newGrid[row][col] = node;\n    this.setState({ grid: newGrid });\n    return false;\n  }\n\n  handleMouseDown(row, col) {\n    const node = this.state.grid[row][col];\n    if (node.isStart) {\n      // we want to drag and drop the start\n      this.setState({ isDraggingStart: true });\n    } else if (node.isFinish) {\n      this.setState({ isDraggingFinish: true });\n    } else {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n      this.setState({ mouseIsPressed: true });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n\n    let newGrid = this.state.grid;\n    const node = newGrid[row][col];\n    if (this.state.isDraggingStart) {\n      // we want to drag and drop the start\n      newGrid = this.getNewGridWithStartMoved(newGrid, row, col);\n    } else if (node.isFinish) {\n      this.setState({ isDraggingFinish: true });\n    } else {\n      newGrid = this.getNewGridWithWallToggled(newGrid, row, col);\n    }\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false,\n    });\n  }\n\n  generateRandomWall() {\n    this.reset();\n\n    const grid = _.cloneDeep(this.state.grid);\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length; j++) {\n        const cell = grid[i][j];\n        if (Math.random() < 0.1 && !cell.isStart && !cell.isFinish) {\n          grid[i][j] = { ...grid[i][j], isWall: true };\n        }\n      }\n    }\n    this.setState({ grid });\n  }\n\n  reset() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n\n  render() {\n    return (\n      <BigContainer>\n        <Container>\n          <Title />\n          <Content>\n            <Button onClick={this.visualizeDjikstra}>\n              Visualize Djikstra's algorithm\n            </Button>\n            <Button onClick={this.visualizeAstar}>\n              Visualize A* algorithm\n            </Button>\n            <Button onClick={this.generateRandomWall}>\n              Generate random Laby\n            </Button>\n            <Button onClick={this.reset}>Reset</Button>\n            {this.state.grid.map((row, rowInd) => {\n              return (\n                <Row key={rowInd}>\n                  {row.map((node, colInd) => {\n                    return (\n                      <Node\n                        key={colInd}\n                        {...node}\n                        onContextMenu={(e) => {\n                          e.preventDefault();\n                          this.handleRightClick(rowInd, colInd);\n                        }}\n                        onMouseDown={(e) => {\n                          // this is only for left click mousedown\n                          if (e.button === 0) {\n                            this.handleMouseDown(rowInd, colInd);\n                          }\n                        }}\n                        onMouseUp={() => this.handleMouseUp()}\n                        onMouseEnter={() =>\n                          this.handleMouseEnter(rowInd, colInd)\n                        }\n                      />\n                    );\n                  })}\n                </Row>\n              );\n            })}\n          </Content>\n        </Container>\n        <Footer />\n      </BigContainer>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}